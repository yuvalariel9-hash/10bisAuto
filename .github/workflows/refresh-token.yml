name: Refresh Token

on:
  schedule:
    # Token refresh every 10 minutes
    - cron: '*/10 * * * *'
  workflow_dispatch: # Allow manual triggering

env:
  TZ: Asia/Jerusalem

jobs:
  refresh-token:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Create config from secrets
      run: |
        cat > config.json << EOF
        {
          "AccessToken": "${{ secrets.ACCESS_TOKEN }}",
          "RefreshToken": "${{ secrets.REFRESH_TOKEN }}",
          "Amount": "${{ secrets.AMOUNT }}",
          "MoneycardId": "${{ secrets.MONEYCARD_ID }}"
        }
        EOF

    - name: Run token refresh
      id: refresh
      run: node github-refresh-token.js
      env:
        ACCESS_TOKEN: ${{ secrets.ACCESS_TOKEN }}
        REFRESH_TOKEN: ${{ secrets.REFRESH_TOKEN }}
        AMOUNT: ${{ secrets.AMOUNT }}
        MONEYCARD_ID: ${{ secrets.MONEYCARD_ID }}

    - name: Update GitHub secrets
      if: steps.refresh.outputs.tokens_updated == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        script: |
          const sodium = require('libsodium-wrappers');
          await sodium.ready;

          // Get repository public key
          const { data: publicKey } = await github.rest.actions.getRepoPublicKey({
            owner: context.repo.owner,
            repo: context.repo.repo,
          });

          // Encrypt and update ACCESS_TOKEN if provided
          if ('${{ steps.refresh.outputs.access_token }}') {
            const accessTokenBytes = Buffer.from('${{ steps.refresh.outputs.access_token }}');
            const publicKeyBytes = Buffer.from(publicKey.key, 'base64');
            const accessTokenEncrypted = sodium.crypto_box_seal(accessTokenBytes, publicKeyBytes);

            await github.rest.actions.createOrUpdateRepoSecret({
              owner: context.repo.owner,
              repo: context.repo.repo,
              secret_name: 'ACCESS_TOKEN',
              encrypted_value: Buffer.from(accessTokenEncrypted).toString('base64'),
              key_id: publicKey.key_id,
            });
            console.log('ACCESS_TOKEN updated');
          }

          // Encrypt and update REFRESH_TOKEN if provided
          if ('${{ steps.refresh.outputs.refresh_token }}') {
            const refreshTokenBytes = Buffer.from('${{ steps.refresh.outputs.refresh_token }}');
            const publicKeyBytes = Buffer.from(publicKey.key, 'base64');
            const refreshTokenEncrypted = sodium.crypto_box_seal(refreshTokenBytes, publicKeyBytes);

            await github.rest.actions.createOrUpdateRepoSecret({
              owner: context.repo.owner,
              repo: context.repo.repo,
              secret_name: 'REFRESH_TOKEN',
              encrypted_value: Buffer.from(refreshTokenEncrypted).toString('base64'),
              key_id: publicKey.key_id,
            });
            console.log('REFRESH_TOKEN updated');
          }

          console.log('Secrets updated successfully');

    - name: Upload logs
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: refresh-logs-${{ github.run_number }}
        path: logs/
        retention-days: 7
